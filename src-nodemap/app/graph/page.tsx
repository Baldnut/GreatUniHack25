"use client"
import Graph from "graphology";
import "@react-sigma/core/lib/style.css";

import { SigmaContainer, useRegisterEvents, useSigma } from "@react-sigma/core";
import { useLayoutCircular } from "@react-sigma/layout-circular";
import { useEffect, useState } from "react";
import { MouseCoords } from "sigma/types";
import Explosion from "react-explode/Siargao";
import { NodeImageProgram } from "@sigma/node-image";
import { useParams, useSearchParams } from "next/navigation";

const ROOT_CITY = "Brussels"


/**
 * Used to run a layout function on first startup
 * @returns 
 */
function PositionNodes() {
    const {positions, assign} = useLayoutCircular()
    assign()
    return <></>
}

/**
 * This datatype is just used to store information about the animation that
 * is shown when two nodes are merged
 */
type ExplodeAnimationData = {
    show: boolean,
    x: number,
    y: number,
    size: number
}

/**
 * This function handles all of the dragging functionality including the little
 * explosion that triggers when two nodes are combined
 * @returns JSX Element that is either animation or null
 */
function AnimateAndDrag() {

    // Stores the node that the user is currently dragging around
    const [draggedNode, setDraggedNode] = useState<string | null>(null);
    
    // Stores information about the location and status of the explosion animation
    const [explodeAnimationData, setExplodeAnimationData] = useState<ExplodeAnimationData>({
        show: false,
        x: 40,
        y: 40,
        size: 40
    });

    const registerEvents = useRegisterEvents();
    const sigma = useSigma();
    const graph = sigma.getGraph();

    // Layout for repositioning nodes
    const {positions, assign} = useLayoutCircular()


    /**
     * Determine if a dragging object overlaps another
     * @param e Mouse event generated by drag
     * @returns Another node name or undefined
     */
    function getOverlappingNode(e: MouseCoords) {
        // Do something the new node is on top of the root
        const neighbours = graph.nodes();
        return neighbours.find(compareNode => {
            // Ignore nodes close to self
            if (compareNode != draggedNode) {
                // We're doing comparisons in screen units
                const comparePos = sigma.graphToViewport({x: graph.getNodeAttribute(compareNode,"x"),
                                                            y: graph.getNodeAttribute(compareNode,"y")})

                // Minimum distance between two nodes for an overlap is dependant on radius
                const minDistance = sigma.scaleSize(graph.getNodeAttribute(compareNode, "size") +
                                        graph.getNodeAttribute(draggedNode, "size"))

                if (graph.getNodeAttribute(compareNode, "cities") && (e.x > comparePos.x - minDistance) && (e.x < comparePos.x + minDistance) &&
                                                                (e.y > comparePos.y - minDistance) && (e.y < comparePos.y + minDistance)) {
                    return true
                }
            }
        })
    }

    // Handling mouse drag events
    useEffect(() => {
        registerEvents({

            // On mouse down on a node, we enable the dragging mode
            downNode: (e) => {
                if (e.node !== ROOT_CITY) { // Don't allow moving root node or POIs
                    setDraggedNode(e.node);
                    sigma.getGraph().setNodeAttribute(e.node, 'highlighted', true);
                    document.body.style.cursor = 'grabbing';
                }
            },

            // On mouse move, if the drag mode is enabled, we change the position of the draggedNode
            mousemovebody: (e) => {
                if (!draggedNode) return;

                // Get new position of node in graph coordinates
                const pos = sigma.viewportToGraph(e);
                graph.setNodeAttribute(draggedNode, 'x', pos.x);
                graph.setNodeAttribute(draggedNode, 'y', pos.y);

                // Do something the new node is on top of another node
                if (getOverlappingNode(e) !== undefined) {
                    graph.setNodeAttribute(draggedNode, "image", "/globe.png")
                } else {
                    graph.setNodeAttribute(draggedNode, "image", graph.getNodeAttribute(draggedNode, "originalImage"))
                }

                // Prevent sigma to move camera
                e.preventSigmaDefault();
                e.original.preventDefault();
                e.original.stopPropagation();

            },

            

            // On mouse up, we reset the dragging mode
            mouseup: (e) => {

                if (draggedNode) {

                    setDraggedNode(null);

                    const recipientNode = getOverlappingNode(e);

                    if (recipientNode !== undefined) {
                        console.log("Will merge", draggedNode, "with", recipientNode);

                        const existingCities:string[] = graph.getNodeAttribute(recipientNode, "cities")
                        const newCititesList: string[] = existingCities.concat(graph.getNodeAttribute(draggedNode, "cities"));

                        graph.setNodeAttribute(recipientNode, "cities", newCititesList)
                        graph.setNodeAttribute(recipientNode, "label", newCititesList.join(", "))

                        // Move all POIs over to merged node
                        graph.neighbors(draggedNode).filter(neighborNode => {
                            return graph.getNodeAttribute(neighborNode, "cities") == undefined
                        }).forEach(poiToMove => {
                            graph.addEdge(poiToMove, recipientNode)
                        })

                        graph.dropNode(draggedNode)

                        // Show animation
                        const animationPos = sigma.graphToViewport({
                            x: graph.getNodeAttribute(recipientNode, "x"),
                            y: graph.getNodeAttribute(recipientNode, "y")
                        })
                        setExplodeAnimationData({
                            show: true,
                            x: animationPos.x,
                            y: animationPos.y,
                            size: graph.getNodeAttribute(recipientNode, "size")*2 *2
                        })

                    } else {
                        // If you drop the node on something other than another node
                        sigma.getGraph().setNodeAttribute(draggedNode, 'highlighted', false);
                    }

                    document.body.style.cursor = 'default';
                    assign();
                }

            },

            // Disable the autoscale at the first down interaction
            mousedown: () => {
                if (!sigma.getCustomBBox()) sigma.setCustomBBox(sigma.getBBox());
            },
            
            // Change cursor on hover
            enterNode: () => {
                if (!draggedNode) {
                document.body.style.cursor = 'grab';
                }
            },

            // Return cursor to default
            leaveNode: () => {
                if (!draggedNode) {
                document.body.style.cursor = 'default';
                }
            }
        })
    }, [registerEvents, sigma, draggedNode]);

    // Display explosion animation in appropriate place
    return <>{  explodeAnimationData.show &&
                <Explosion size={explodeAnimationData.size}
                           style={{ width: explodeAnimationData.size, height: explodeAnimationData.size, position: "fixed",
                                    left: explodeAnimationData.x, top: explodeAnimationData.y, translate: "-50% -50%" }}
                           delay={0} repeatDelay={0} repeat={0} onComplete={() => {setExplodeAnimationData({...explodeAnimationData, show: false})}}
                                                       />}</>
}

function POIClick() {
    const registerEvents = useRegisterEvents();
    const sigma = useSigma();
    const graph = sigma.getGraph();

     // Handling mouse drag events
    useEffect(() => {
        registerEvents({
            clickNode: (e) => {
                if (!graph.getNodeAttribute(e.node, "cities")) {
                    const clickTargetID = graph.getNodeAttribute(e.node, "poiID");
                    console.log("Clicked on", clickTargetID)
                    window.parent.postMessage(clickTargetID, "*");
                }
            }
        })
    }, [registerEvents, graph]);

    return <></>
}


type NearbyResponse = {
    places: {
            displayName: {
                languageCode: string,
                text: string
            },
            id: string,
            location: {
                latitude: string,
                longitude: string
            }
        }[]
}

type NearbyCityResponse = {
    places: {
        displayName: string
        lat: string,
        lon: string
    }[]
}

/**
 * Actually display the graph
 * @returns
 */
export default function DisplayGraph() {
    const graph = new Graph();

    const params = useSearchParams();

    const baseCity = params.get("name");
    const baseLat = params.get("lat")
    const baseLon = params.get("lon")

    // Add baseCity Node
    graph.addNode(baseCity, { x: 1, y:0, size: 100, label: baseCity, color: "#ffffff", cities: [baseCity], image: "/globe.png", originalImage: "/globe.png"});

    // Populate POIs for base city
    fetch(`https://timefactories.com/cgi-bin/guh/places.cgi/nearby?lat=${baseLat}&lon=${baseLon}&radius=5000&types=museum&limit=12`).then(response => {
        response.json().then((nearbyPlaces: NearbyResponse) => {
            nearbyPlaces.places.forEach(poi => {
                graph.addNode(poi.displayName.text, { x: 0, y: 0, size: 10, label: poi.displayName.text, poiID: poi.id, labelFont: "Poppins" });
                graph.addEdge(poi.displayName.text, baseCity)
            })
        })
    })

    // Get Adjacent Cities
    fetch(`https://timefactories.com/cgi-bin/guh/places.cgi/l_nearby?poi=${baseCity}&radius=50000`).then(response => {
        response.json().then((nearbyCities: NearbyCityResponse) => {
            nearbyCities.places.forEach(place => {
                graph.addNode(place.displayName, { x: 1, y:0, size: 50, label: place.displayName, cities: [place.displayName], image: "/globe_lightened.png", originalImage: "/globe_lightened.png"});
                graph.addEdge(place.displayName, baseCity)
            })
        })
    })
  
    return (
    <>
        <SigmaContainer style={{ height: "100vh", width: "100vw" }} graph={graph} settings={{
            allowInvalidContainer: true,
            defaultNodeType: 'image',
            nodeProgramClasses: {
                image: NodeImageProgram,
            },
        }}>
            <PositionNodes />
            <AnimateAndDrag />
            <POIClick />
        </SigmaContainer>
    </>
    );
};
