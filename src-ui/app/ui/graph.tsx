"use client"
import Graph from "graphology";
import "@react-sigma/core/lib/style.css";

import { SigmaContainer, useRegisterEvents, useSigma } from "@react-sigma/core";
import { useLayoutCircular } from "@react-sigma/layout-circular";
import { useEffect, useState } from "react";
import { MouseCoords } from "sigma/types";
import Explosion from "react-explode/Siargao";
import { NodeImageProgram } from "@sigma/node-image";

const ROOT_CITY = "Brussels"

const LOCALITIES_TEST = [
    {
        from: "Brussels",
        nearby: [
            {
                name: "Bruges"
            },
            {
                name: "Anderlecht"
            },
            {
                name: "Leuven"
            }
        ]
    }
]

const POI_TEST = [
    {
        name: "Brussels",
        POIs: [
            {
                name: "Sewer Museum"
            },
            {
                name: "EU Parliament"
            },
            {
                name: "Atomium"
            },
            {
                name: "Grand Place"
            }
        ]
    },
    {
        name: "Bruges",
        POIs: [
            {
                name: "Lumina"
            },
            {
                name: "Cocao Story"
            }
        ]
    },
    {
        name: "Anderlecht",
        POIs: [
            {
                name: "IKEA"
            }
        ]
    },
    {
        name: "Leuven",
        POIs: [
            {
                name: "Vrijheidsboom"
            }
        ]
    }
]

/**
 * Used to run a layout function on first startup
 * @returns 
 */
function PositionNodes() {
    const {positions, assign} = useLayoutCircular()
    assign()
    return <></>
}

/**
 * This datatype is just used to store information about the animation that
 * is shown when two nodes are merged
 */
type ExplodeAnimationData = {
    show: boolean,
    x: number,
    y: number,
    size: number
}

/**
 * This function handles all of the dragging functionality including the little
 * explosion that triggers when two nodes are combined
 * @returns JSX Element that is either animation or null
 */
function AnimateAndDrag() {

    // Stores the node that the user is currently dragging around
    const [draggedNode, setDraggedNode] = useState<string | null>(null);
    
    // Stores information about the location and status of the explosion animation
    const [explodeAnimationData, setExplodeAnimationData] = useState<ExplodeAnimationData>({
        show: false,
        x: 40,
        y: 40,
        size: 40
    });

    const registerEvents = useRegisterEvents();
    const sigma = useSigma();
    const graph = sigma.getGraph();


    /**
     * Determine if a dragging object overlaps another
     * @param e Mouse event generated by drag
     * @returns Another node name or undefined
     */
    function getOverlappingNode(e: MouseCoords) {
        // Do something the new node is on top of the root
        const neighbours = graph.nodes();
        return neighbours.find(compareNode => {
            // Ignore nodes close to self
            if (compareNode != draggedNode) {
                // We're doing comparisons in screen units
                const comparePos = sigma.graphToViewport({x: graph.getNodeAttribute(compareNode,"x"),
                                                            y: graph.getNodeAttribute(compareNode,"y")})

                // Minimum distance between two nodes for an overlap is dependant on radius
                const minDistance = sigma.scaleSize(graph.getNodeAttribute(compareNode, "size") +
                                        graph.getNodeAttribute(draggedNode, "size"))

                if (graph.getNodeAttribute(compareNode, "cities") && (e.x > comparePos.x - minDistance) && (e.x < comparePos.x + minDistance) &&
                                                                (e.y > comparePos.y - minDistance) && (e.y < comparePos.y + minDistance)) {
                    return true
                }
            }
        })
    }

    // Handling mouse drag events
    useEffect(() => {
        registerEvents({

            // On mouse down on a node, we enable the dragging mode
            downNode: (e) => {
                if (e.node !== ROOT_CITY) { // Don't allow moving root node
                    setDraggedNode(e.node);
                    sigma.getGraph().setNodeAttribute(e.node, 'highlighted', true);
                    document.body.style.cursor = 'grabbing';
                }
            },

            // On mouse move, if the drag mode is enabled, we change the position of the draggedNode
            mousemovebody: (e) => {
                if (!draggedNode) return;

                // Get new position of node in graph coordinates
                const pos = sigma.viewportToGraph(e);
                graph.setNodeAttribute(draggedNode, 'x', pos.x);
                graph.setNodeAttribute(draggedNode, 'y', pos.y);

                // Do something the new node is on top of another node
                if (getOverlappingNode(e) !== undefined) {
                    graph.setNodeAttribute(draggedNode, "image", "/globe.png")
                } else {
                    graph.setNodeAttribute(draggedNode, "image", graph.getNodeAttribute(draggedNode, "originalImage"))
                }

                // Prevent sigma to move camera
                e.preventSigmaDefault();
                e.original.preventDefault();
                e.original.stopPropagation();

            },

            

            // On mouse up, we reset the dragging mode
            mouseup: (e) => {

                if (draggedNode) {

                    setDraggedNode(null);

                    const recipientNode = getOverlappingNode(e);

                    if (recipientNode !== undefined) {
                        console.log("Will merge", draggedNode, "with", recipientNode);

                        const existingCities:string[] = graph.getNodeAttribute(recipientNode, "cities")
                        const newCititesList: string[] = existingCities.concat(graph.getNodeAttribute(draggedNode, "cities"));

                        graph.setNodeAttribute(recipientNode, "cities", newCititesList)
                        graph.setNodeAttribute(recipientNode, "label", newCititesList.join(", "))

                        // Move all POIs over to merged node
                        graph.neighbors(draggedNode).filter(neighborNode => {
                            return graph.getNodeAttribute(neighborNode, "cities") == undefined
                        }).forEach(poiToMove => {
                            graph.addEdge(poiToMove, recipientNode)
                        })

                        graph.dropNode(draggedNode)

                        // Show animation
                        const animationPos = sigma.graphToViewport({
                            x: graph.getNodeAttribute(recipientNode, "x"),
                            y: graph.getNodeAttribute(recipientNode, "y")
                        })
                        setExplodeAnimationData({
                            show: true,
                            x: animationPos.x,
                            y: animationPos.y,
                            size: graph.getNodeAttribute(recipientNode, "size")*2 *2
                        })

                    } else {
                        // If you drop the node on something other than another node
                        sigma.getGraph().setNodeAttribute(draggedNode, 'highlighted', false);
                    }

                    document.body.style.cursor = 'default';
                }

            },

            // Disable the autoscale at the first down interaction
            mousedown: () => {
                if (!sigma.getCustomBBox()) sigma.setCustomBBox(sigma.getBBox());
            },
            
            // Change cursor on hover
            enterNode: () => {
                if (!draggedNode) {
                document.body.style.cursor = 'grab';
                }
            },

            // Return cursor to default
            leaveNode: () => {
                if (!draggedNode) {
                document.body.style.cursor = 'default';
                }
            }
        })
    }, [registerEvents, sigma, draggedNode]);

    // Display explosion animation in appropriate place
    return <>{  explodeAnimationData.show &&
                <Explosion size={explodeAnimationData.size}
                           style={{ width: explodeAnimationData.size, height: explodeAnimationData.size, position: "fixed",
                                    left: explodeAnimationData.x, top: explodeAnimationData.y, translate: "-50% -50%" }}
                           delay={0} repeatDelay={0} repeat={0} onComplete={() => {setExplodeAnimationData({...explodeAnimationData, show: false})}}
                                                       />}</>
}

/**
 * Actually display the graph
 * @returns
 */
export default function DisplayGraph() {
    const graph = new Graph();

    POI_TEST.forEach(city => {
        if (city.name == ROOT_CITY) {
            graph.addNode(city.name, { x: 1, y:0, size: 100, label: city.name, color: "#687A78", cities: [city.name], image: "/globe.png", originalImage: "/globe.png"});
        } else {
            graph.addNode(city.name, { x: 0, y: 0, size: 50, label: city.name, color: "#D3D8D7", opacity: 0.5, cities: [city.name], image: "/globe_lightened.png", originalImage: "/globe_lightened.png" });
            graph.addEdge(city.name, ROOT_CITY) // Connect all other cities to root city
        }

        // Add POIs for each city
        city.POIs.forEach(poi => {
            graph.addNode(poi.name, { x: 0, y: 0, size: 10, label: poi.name });
            graph.addEdge(poi.name, city.name)
        });
    })
  
    return (
    <>
        <SigmaContainer style={{ height: "100vh", width: "100vw" }} graph={graph} settings={{
            allowInvalidContainer: true,
            defaultNodeType: 'image',
            nodeProgramClasses: {
                image: NodeImageProgram,
            },
        }}>
            <PositionNodes />
            <AnimateAndDrag />
        </SigmaContainer>
    </>
    );
};
